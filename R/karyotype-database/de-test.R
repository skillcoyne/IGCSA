
#library("DEoptim")
source("lib/selection.R")

## this is just something to play with at the moment - genetic algorithm with dissociative mating
# The fitness is being calculated based on the sum of adjusted band probabilities multipled by the number of bands/number of selected bands
# this results in more diversity than a cost function based directly on the probability of each band 
## ...this is currently biasing towards fewer breakpoints in a genome, this may be correct but I think the result is to aim for individuals with fewer breakpoints 
# so the "best" genomes trend towards fewer breakpoints...erm...
obj_func<-function(ind, per_band_e)
  {
  r = per_band_e[names(ind[which(ind > 0)])]
  cost = sum(r)#*(length(per_band_e)/length(r))  # commenting out the length adjustment drops the number of breakpoints per individual  
  if (cost == 0) cost = 100  # while technically a genome with no mutations is perfectly fit that is not what I'm looking for
  return(cost)
  }

random_ind_p<-function(bands, mean)
  {
  rpop = vector("numeric", nrow(bands))
  names(rpop) = bands$bands

  count = sample(rpois(200, mean), 1, replace=F)
  for (i in 1:count)
    rpop[ bands[roll(bands$p), 'bands'] ] = 1

  return(rpop)
  }


random_ind<-function(bands, mean)
  {
  rpop = vector("numeric", length(bands))
  names(rpop) = bands
  
  count = sample(rpois(200, mean), 1, replace=F)
  #count = sample(c(min:max), 1, replace=T)
  
  rpop[ sample(bands, count)] = 1
  return(rpop)  
  }

# ----------------------------------- #

df = read.table("~/Analysis/Database/cancer/all-bp-prob.txt", header=T, sep="\t")
df = df[order(-df$bp.prob),]
df = set.probs(df$bp.prob, df)

df$bands = paste(df[,'chr'], df[,'band'], sep="")

chr = read.table("~/Analysis/Database/cancer/chr_instability_prob.txt", sep="\t", col.names=c('chr','prob'))
chr = chr[order(-chr$prob),]
chr = set.probs(chr$prob, chr)

bands = paste(df[,'chr'], df[,'band'], sep="")

## INITIAL POPULATION
## Could select bands completely randomly 
initial_pop = matrix(0, ncol=length(bands), nrow=100)
colnames(initial_pop) = bands

## for now, will randomly decide how many breakpoints should be selected
for (i in 1:nrow(initial_pop))
  {
  initial_pop[i,] = random_ind_p(df[,c('bands','p')], 10)
  #initial_pop[i,] = random_ind(bands, 10)
  }
  

## Evaluate the initial population against my fitness evaluation...not sure how...
# probability of each breakpoint adjusted by the probability of the chromosome??
band_eval = vector("numeric", length(bands))
names(band_eval) = bands
for (b in bands)
  {
  bp = df[df$bands == b, ]
  c = chr[ which(chr[,'chr'] == bp[,'chr']), ]
  band_eval[bp$bands] = bp$bp.prob/c$prob  
  #band_eval[bp$bands] = bp$bp.prob
  }


## evaluate the first population
initial_cost = vector("numeric", nrow(initial_pop)) 
names(initial_cost) = 1:nrow(initial_pop)
for (i in 1:nrow(initial_pop))
  initial_cost[i] = obj_func(initial_pop[i,], band_eval)

## for the next Generation perform differential mutation

F = 0.9 # this is1 supposed to be a constant, randomly selected right now  vi = xro + F * (xr1 - xr2)

## CROSSOVER
CR = 0.7  # crossover constant between 0,1

pop = initial_pop
cost = initial_cost
# I think that the trial crossover vector is generated by evaluation of a random number between 0,1 to the CR 
generation = 1

repeat
  {  
  print(paste("Generation", generation))
  newPop = pop  # default
  for (i in 1:nrow(pop))
    {
    ## differential MUTATION step, randomly select 3 members of the population
    samples = pop[sample(nrow(pop), 3), ]
    trial = samples[3,]  # default values come from the target vector
    
    j = sample(c(1:length(trial)), 1) # randomly select first trial  I"m not sure why it jumps around like this
    # crossover
    for (k in 1:length(trial))
      {  
      if ( k == length(trial) |  runif(1,0,1) < CR )  
        {
        ## v1 is generated by adding the differences of xr1 and xr2 with a weighting factor F (0,2)
        v1 = samples[3,j] + F * (samples[1,j] - samples[2,j])
        if (v1 < 0) v1 = 0 # min
        if (v1 > 0) v1 = 1 # max
        trial[j] = v1 ## replace default with the calculated value
        }
      j = (j+1) %% length(trial)+1  ## jumps around, why? "noisy random vector"
      if (j == 0) warning("j is 0") # shouldn't happen
      }
    # additional mutation step on the individual that crossed over?
    mut_count = sample(c(0:10), 1, replace=T)
    if (mut_count > 0) trial[sample(bands, mut_count)] = 1
    
    ## evaluate and select
    score = obj_func(trial, band_eval)
  
    if (score <= cost[i]) # if it improves keep it and its score otherwise the original will be retained
      {
      newPop[i,] = trial
      cost[i] = score
      }
    
    rm(samples, trial)
    }
  
  pop = newPop
  rm(newPop) # just to make sure
  
  ## additional mutation step?
  mutation = sample(nrow(pop), sample(round(nrow(pop)/8)),1)
  for (i in mutation)
    {
    if (runif(1,0,1) < CR)  # use the crossover constant for now but should maybe have it's own?
      {
      count = sample(rpois(200,4), 1) # random number of breakpoints to flip
      j = sample(c(1:length(pop[i,])), 1) # use to randomly select the breakpoints to flip
      for(k in 1:count)
        {
        if (pop[i,j] == 0) pop[i,j] = 1
        else pop[i,j] = 0
        j = (j+1) %% length(pop[i,])+1  ## jumps around, why? "noisy random vector"
        }
      cost[i] = obj_func(pop[i,], band_eval) 
      }
    }
  
  generation = generation + 1
  if (generation > 50) break
  }


count = 0
x = combn(1:nrow(pop), 2)
for (i in 1:ncol(x))
  {
  col = x[,i]
  a = names( which(pop[col[1],] > 0))
  b = names( which(pop[col[2],] > 0))
  if (length(a) == length(b) & a == b) count = count +1
  }

sum(pop)/nrow(pop)

min(apply(pop,1,function(x) sum(x)))
max(apply(pop,1,function(x) sum(x)))

#apply(pop,1,function(x) sum(x))

s = colSums(pop)
#apply(initial_pop,1,function(x) sum(x))
#s[which(s > 0)]

  
unc = 0
for (i in 1:nrow(pop))
  {
  a = names( which(pop[i,] > 0))
  b = names( which(initial_pop[i,] > 0))
  if (length(a) == length(b) & a == b) unc = unc +1
  }


#sort(colSums(pop))


tk = 100240
bps = read.table("~/Data/sky-cgh/output/current/noleuk-breakpoints.txt", header=T, sep="\t")
bps = bps[-which(bps$total.karyotypes < 20),]
real = bps[, c('chr','band', 'total.karyotypes')]
real = real[order(-real$total.karyotypes),]

plot(real$total.karyotypes/tk, type='l', main="Karyotype Breakpoint Counts")
plot(sort(colSums(pop), decreasing=T)/nrow(pop), type='l', col="red", main="DE Breakpoint Counts")

print(paste( (count/nrow(pop))*100, "% identical", sep="")) # I'm getting about 60% of the individuals with identical breakpoints.  Not a very diverse population
print(paste(unc, "individuals unchanged from initial population"))
