
#library("DEoptim")
source("lib/selection.R")

## this is just something to play with at the moment - genetic algorithm with dissociative mating
# The fitness is being calculated based on the sum of adjusted band probabilities multipled by the number of bands/number of selected bands
# this results in more diversity than a cost function based directly on the probability of each band 
## ...this is currently biasing towards fewer breakpoints in a genome, this may be correct but I think the result is to aim for individuals with fewer breakpoints 
# so the "best" genomes trend towards fewer breakpoints...erm...
obj_func<-function(ind, per_band_e)
  {
  r = per_band_e[names(ind[which(ind > 0)])]
  cost = sum(r)#*(length(per_band_e)/length(r))  # commenting out the length adjustment drops the number of breakpoints per individual  
  if (cost == 0) cost = 100  # while technically a genome with no mutations is perfectly fit that is not what I'm looking for
  return(cost)
  }

random_ind_p<-function(bands, mean)
  {
  rpop = vector("numeric", nrow(bands))
  names(rpop) = bands$bands

  count = sample(rpois(200, mean), 1, replace=F)
  for (i in 1:count)
    rpop[ bands[roll(bands$p), 'bands'] ] = 1

  return(rpop)
  }

random_ind<-function(bands, mean)
  {
  rpop = vector("numeric", length(bands))
  names(rpop) = bands
  
  count = sample(rpois(200, mean), 1, replace=F)
  #count = sample(c(min:max), 1, replace=T)
  
  rpop[ sample(bands, count)] = 1
  return(rpop)  
  }

test_dispersion<-function(population)
  {
  same = vector("character", nrow(population))
  for(i in 1:nrow(population))
    {
    a = which( population[i,] > 0  )
    bands = paste(names(a), collapse=", ")
    same[i] = bands
    }
  same = table(same)

  return( list("cv"=(sd(same)/mean(same)), "quantile"=quantile(same), "range"=range(same), "table"=same) )
  }


# ----------------------------------- #

df = read.table("~/Analysis/Database/cancer/all-bp-prob.txt", header=T, sep="\t")
df = df[order(-df$bp.prob),]
df = set.probs(df$bp.prob, df)

df$bands = paste(df[,'chr'], df[,'band'], sep="")

chr = read.table("~/Analysis/Database/cancer/chr_instability_prob.txt", sep="\t", col.names=c('chr','prob'))
chr = chr[order(-chr$prob),]
chr = set.probs(chr$prob, chr)

bands = paste(df[,'chr'], df[,'band'], sep="")

## INITIAL POPULATION
## Could select bands completely randomly 
initial_pop = matrix(0, ncol=length(bands), nrow=200)
colnames(initial_pop) = bands

## for now, will randomly decide how many breakpoints should be selected
for (i in 1:nrow(initial_pop))
  {
  initial_pop[i,] = random_ind_p(df[,c('bands','p')], 5)
  #initial_pop[i,] = random_ind(bands, 10)
  }
  

## Evaluate the initial population against my fitness evaluation...not sure how...
# probability of each breakpoint adjusted by the probability of the chromosome??
band_eval = vector("numeric", length(bands))
names(band_eval) = bands
for (b in bands)
  {
  bp = df[df$bands == b, ]
  c = chr[ which(chr[,'chr'] == bp[,'chr']), ]
  band_eval[bp$bands] = bp$bp.prob/c$prob  
  #band_eval[bp$bands] = bp$bp.prob
  }


## evaluate the first population
initial_cost = vector("numeric", nrow(initial_pop)) 
names(initial_cost) = 1:nrow(initial_pop)
for (i in 1:nrow(initial_pop))
  initial_cost[i] = obj_func(initial_pop[i,], band_eval)

## for the next Generation perform differential mutation

F = 0.9 # this is1 supposed to be a constant, randomly selected right now  vi = xro + F * (xr1 - xr2)

## CROSSOVER
CR = 0.7  # crossover constant between 0,1

## Mutation rate between 0,1
MR = 0.8

pop = initial_pop

test = test_dispersion(pop)
print(paste("INITIAL POPULATION CV:", test$cv))
print(paste("Unrepresented bps:",length(which(colSums(pop) <= 0))/ncol(pop)))

test_pts = as.data.frame(matrix(0, ncol=3))
colnames(test_pts) = c('cv','unrep', 'mut')

cost = initial_cost
# I think that the trial crossover vector is generated by evaluation of a random number between 0,1 to the CR 
generation = 1
max_gen = 150
gm = vector("logical", max_gen)

repeat
  {  
  print(paste("Generation", generation))
  newPop = pop  # default
  for (i in 1:nrow(pop))
    {
    ## differential CROSSOVER step, randomly select 3 members of the population
    samples = pop[sample(nrow(pop), 3), ]
    trial = samples[3,]  # default values come from the target vector
    
    j = sample(c(1:length(trial)), 1) # randomly select first trial  I"m not sure why it jumps around like this
    # crossover
    for (k in 1:length(trial))
      {  
      if ( k == length(trial) |  runif(1,0,1) < CR )  
        {
        ## v1 is generated by adding the differences of xr1 and xr2 with a weighting factor F (0,2)
        v1 = samples[3,j] + F * (samples[1,j] - samples[2,j])
        if (v1 < 0) v1 = 0 # min
        if (v1 > 0) v1 = 1 # max
        trial[j] = v1 ## replace default with the calculated value
        }
      j = (j+1) %% length(trial)+1  ## jumps around, why? "noisy random vector"
      if (j == 0) warning("j is 0") # shouldn't happen
      }
    # additional mutation step on the individual that crossed over?
    mut_count = sample(c(0:10), 1, replace=T)
    if (mut_count > 0) trial[sample(bands, mut_count)] = 1
    
    ## evaluate and select
    score = obj_func(trial, band_eval)
  
    if (score <= cost[i]) # if it improves keep it and its score otherwise the original will be retained
      {
      newPop[i,] = trial
      cost[i] = score
      }
    
    rm(samples, trial)
    }
  
  pop = newPop
  rm(newPop) # just to make sure
  
  ## additional mutation step?
  m = F
  mutation = sample(nrow(pop), sample(round(nrow(pop)/8)),1)
  for (i in mutation)
    {
    if (runif(1,0,1) < MR)  
      {
      m = T
      count = sample(rpois(200,4), 1) # random number of breakpoints to flip
      j = sample(c(1:length(pop[i,])), 1) # use to randomly select the breakpoints to flip
      for(k in 1:count)
        {
        if (pop[i,j] == 0) pop[i,j] = 1
        else pop[i,j] = 0
        j = (j+1) %% length(pop[i,])+1  ## jumps around, why? "noisy random vector"
        }
      cost[i] = obj_func(pop[i,], band_eval) 
      }
    }
  
  generation = generation + 1

  if (m) gm[generation] = TRUE
    #points(generation, 0, col="green", type="o", pch=*)
  
  if (generation > 40 & generation %% 5 == 0)
    {
    test = test_dispersion(pop)
    rep = length(which(colSums(pop) <= 0))/ncol(pop)
    
    print(paste("CV:", test$cv))
    print(paste("Unrepresented bps:", rep))
    
    test_pts[generation/5, 'cv'] = test$cv
    test_pts[generation/5, 'unrep'] = rep
    test_pts[generation/5, 'mut'] = m
    
    #points(generation, test$cv, col="red", type="o",pch=18)
    #points(generation, rep, col="blue", type="o", pch=20)
    
    if (test$cv <= 0.15 & rep <= 0.18) break
    }
  
  if (generation > max_gen) break
  }

#plot(c(1:30),ylim=c(0,0.5), ylab="", xlab="Generation", type='n')
#points(test_pts[,1], col="blue", type='o', pch=18)
#points(test_pts[,2], col="red", type='o', pch=17)
#legend("topright", legend=c("CV", "Unrep BPs"), col=c("blue", "red"), pch=c(18,17))


initial_same = test_dispersion(initial_pop)


final_same = test_dispersion(pop)
final = sort(final_same$table)


length(which(colSums(pop) <= 0))/ncol(pop)

length(which(colSums(initial_pop) <= 0))/ncol(initial_pop)


unc = 0
for (i in 1:nrow(pop))
  {
  a = names( which(pop[i,] > 0))
  b = names( which(initial_pop[i,] > 0))
  if (length(a) == length(b) & a == b) unc = unc +1
  }


#sort(colSums(pop))

#par(mfrow=c(2,1))
#tk = 100240
#bps = read.table("~/Data/sky-cgh/output/current/noleuk-breakpoints.txt", header=T, sep="\t")
#bps = bps[-which(bps$total.karyotypes < 20),]
#real = bps[, c('chr','band', 'total.karyotypes')]
#real = real[order(-real$total.karyotypes),]

#plot(real$total.karyotypes/tk, type='l', main="Karyotype Breakpoint Counts")
#plot(sort(colSums(pop), decreasing=T)/nrow(pop), type='l', col="red", main="DE Breakpoint Counts")


print(paste(unc, "individuals unchanged from initial population"))
print(paste(max(initial_same$table)/nrow(initial_pop)*100, "% of initial population was identical", sep=""))
print(paste( (max(final)/nrow(pop))*100, "% of the population is identical", sep="")  )

print("Fitness summary")
summary(cost)
sd(cost)
sd(cost)/mean(cost)



