/**
 * org.lcsb.lu.igcsa.ea
 * Author: sarah.killcoyne
 * Copyright University of Luxembourg and Luxembourg Centre for Systems Biomedicine 2013
 * Open Source License Apache 2.0 http://www.apache.org/licenses/LICENSE-2.0.html
 */


package org.lcsb.lu.igcsa.ea;

import org.apache.commons.lang.math.IntRange;
import org.apache.commons.lang.math.Range;
import org.apache.commons.math3.distribution.IntegerDistribution;
import org.apache.commons.math3.distribution.PoissonDistribution;
import org.apache.log4j.Logger;
import org.lcsb.lu.igcsa.database.Band;
import org.lcsb.lu.igcsa.database.KaryotypeDAO;
import org.lcsb.lu.igcsa.prob.Probability;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.uncommons.maths.number.NumberGenerator;
import org.uncommons.maths.random.MersenneTwisterRNG;
import org.uncommons.watchmaker.framework.*;
import org.uncommons.watchmaker.framework.factories.AbstractCandidateFactory;
import org.uncommons.watchmaker.framework.operators.AbstractCrossover;

import java.util.*;

public class TestWM
  {
  static Logger log = Logger.getLogger(TestWM.class.getName());


  public static void main(String[] args) throws Exception
    {

    ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"classpath*:spring-config.xml", "classpath*:/conf/genome.xml", "classpath*:/conf/database-config.xml"});

    KaryotypeDAO dao = (KaryotypeDAO) context.getBean("karyotypeDAO");

    Probability bandProbability = dao.getGeneralKarytoypeDAO().getOverallBandProbabilities();


    // creates the initial population
    CandidateFactory<Set<Band>> candidateFactory = new BandCandidateFactory(bandProbability, new PoissonDistribution(5));

    Set<Band> pop = candidateFactory.generateRandomCandidate(new Random());

    EvolutionaryOperator<Set<Band>> operator = new DECrossoverOperator(0.9, 0.7);

    new BandSetEvaluator(bandProbability);


    //EvolutionEngine<Set<Band>> engine = new GenerationalEvolutionEngine<Set<Band>>();




    }




  public static class BandCandidateFactory extends AbstractCandidateFactory<Set<Band>>
    {
    private Probability bandProbability;
    private IntegerDistribution distribution;

    public BandCandidateFactory(Probability bandProbability, IntegerDistribution distribution)
      {
      this.distribution = distribution;
      this.bandProbability = bandProbability;
      }

    @Override
    public Set<Band> generateRandomCandidate(Random random)
      {
      int maxBands = distribution.sample();
      Set<Band> bands = new HashSet<Band>(maxBands);
      for (int i=0; i<maxBands; i++)
        bands.add((Band) bandProbability.roll());

      log.info(bands);

      return bands;
      }
    }





  public static class DECrossoverOperator implements EvolutionaryOperator<Set<Band>>
    {
    private double F = 0.5; // between 0,2
    private double CR = 0.5;

    private final Range FLIMIT = new IntRange(0,2);
    private final Range CRLIMIT = new IntRange(0,1);

    public DECrossoverOperator(double F, double crossoverRate)
      {
      if (!FLIMIT.containsDouble(F) || !CRLIMIT.containsDouble(crossoverRate))
        throw new IllegalArgumentException("F must be between 0,2 and CR must be between 0,1");

      this.F = F;
      this.CR = crossoverRate;
      }

    @Override
    public List<Set<Band>> apply(List<Set<Band>> sets, Random random)
      {
      if (sets.size() != 3)
        throw new IllegalArgumentException("Three individuals required for crossover");

      Set<Band> xr1 = sets.get(0);
      Set<Band> xr2 = sets.get(1);
      Set<Band> xr3 = sets.get(2);
      Set<Band> trial = sets.get(2);

      // I'm only going to care about bands that show up in one of my sets
      List<Band> all = new ArrayList<Band>(xr1);
      all.addAll(xr2);
      all.addAll(xr3);

      //randomly select first trial
      Collections.shuffle(all, new MersenneTwisterRNG());
      Iterator<Band> bI = all.iterator();
      while(bI.hasNext())
        {
        Band b = bI.next();

        int x1 = (xr1.contains(b))? 1: 0;
        int x2 = (xr2.contains(b))? 1: 0;
        int x3 = (xr3.contains(b))? 1: 0;

        //  v1 is generated by adding the differences of xr1 and xr2 with a weighting factor F (0,2)
        double v1 = x3 + F * (x1 - x2);

        if (v1 > 0) trial.add(b);
        if (v1 < 0 && trial.contains(b)) trial.remove(b);

        bI.remove();
        Collections.shuffle(all, new MersenneTwisterRNG()); // "noisy random vector"
        }

      // supposed to evaluate fitness and replace current individual but that happens elsewhere.  So for the moment I'll return all 4 and see where I deal with this later
      sets.add(trial);

      return sets;
      }
    }


  public static class BandSetEvaluator implements FitnessEvaluator<Set<Band>>
    {
    private Map<Band, Double> probabilities = new HashMap<Band, Double>();

    public BandSetEvaluator(Probability bandProbability)
      {
      for (Map.Entry<Double, Object> entry: bandProbability.getProbabilities().entrySet())
        probabilities.put((Band) entry.getValue(), entry.getKey());
      }

    @Override
    public double getFitness(Set<Band> bands, List<? extends Set<Band>> sets)
      {
      double score = 0.0;
      for (Band b: bands)
        score += probabilities.get(b);

      // while technically a genome with no mutations is perfectly fit that is not what I'm looking for
      if (score == 0) score = 100;

      return score;
      }

    @Override
    public boolean isNatural()  // in my case higher fitness values actually means lower fitness
      {
      return false;
      }
    }




  }
