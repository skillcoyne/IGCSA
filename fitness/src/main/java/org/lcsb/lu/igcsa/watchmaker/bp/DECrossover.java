/**
 * org.lcsb.lu.igcsa.watchmaker
 * Author: sarah.killcoyne
 * Copyright University of Luxembourg and Luxembourg Centre for Systems Biomedicine 2013
 * Open Source License Apache 2.0 http://www.apache.org/licenses/LICENSE-2.0.html
 */


package org.lcsb.lu.igcsa.watchmaker.bp;

import org.apache.commons.lang.math.DoubleRange;
import org.apache.commons.lang.math.Range;
import org.apache.log4j.Logger;
import org.lcsb.lu.igcsa.database.Band;
import org.uncommons.maths.random.MersenneTwisterRNG;
import org.uncommons.watchmaker.framework.EvolutionaryOperator;
import org.uncommons.watchmaker.framework.FitnessEvaluator;

import java.util.*;

public class DECrossover  implements EvolutionaryOperator<Set<Band>>
  {
  static Logger log = Logger.getLogger(DECrossover.class.getName());

  private double F = 0.5; // between 0,2
  private double CR = 0.5;

  private FitnessEvaluator<Set<Band>> fitness;

  private final Range FLIMIT = new DoubleRange(0, 2);
  private final Range CRLIMIT = new DoubleRange(0, 1);


  public DECrossover(double f, double cr, FitnessEvaluator<Set<Band>> fitness)
    {
    if (!FLIMIT.containsDouble(F) || !CRLIMIT.containsDouble(cr))
      throw new IllegalArgumentException("F must be between 0,2 and CR must be between 0,1");

    this.F = f;
    this.CR = cr;
    this.fitness = fitness;
    }

  @Override
  public List<Set<Band>> apply(List<Set<Band>> sets, Random random)
    {
    Collections.shuffle(sets);

    Set<Band> xr1 = sets.get(0);
    Set<Band> xr2 = sets.get(1);
    Set<Band> xr3 = sets.get(2);

    Set<Band> trial = new HashSet<Band>(sets.get(2));

    // I'm only going to care about bands that show up in one of my sets
    List<Band> all = new ArrayList<Band>(xr1);
    all.addAll(xr2);
    all.addAll(xr3);

    //randomly select first trial
    Collections.shuffle(all, new MersenneTwisterRNG());
    Iterator<Band> bI = all.iterator();
    while (bI.hasNext())
      {
      Band b = bI.next();

      if (new Random().nextDouble() < CR) //
        {
        //log.info("Crossing over");
        int x1 = (xr1.contains(b)) ? 1 : 0;
        int x2 = (xr2.contains(b)) ? 1 : 0;
        int x3 = (xr3.contains(b)) ? 1 : 0;

        //  v1 is generated by adding the differences of xr1 and xr2 with a weighting factor F (0,2)
        double v1 = x3 + F * (x1 - x2);

        if (v1 >= 0)
          trial.add(b);
        if (v1 < 0 && trial.contains(b))
          trial.remove(b);
        }

      bI.remove();
      Collections.shuffle(all, new MersenneTwisterRNG()); // "noisy random vector"
      }

    if (fitness.getFitness(trial, sets) <= fitness.getFitness(xr3, sets))
      {
      sets.remove(xr3);
      sets.add(trial);
      log.info("adding XO individual");
      }

    return sets;
    }
  }
